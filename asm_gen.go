// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a
// Modified BSD License that can be found in
// the LICENSE file.

// +build ignore

package main

import (
	"fmt"

	"github.com/tmthrgd/asm"
)

const header = `// Code generated by go run asm_gen.go.

// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a
// Modified BSD License that can be found in
// the LICENSE file.

// +build amd64,!gccgo,!appengine
`

func SwapUint128Asm(a *asm.Asm) {
	a.NewFunction("SwapUint128")
	a.NoSplit()

	addr := a.Argument("addr", 8)
	newData := a.Argument("new", 8)
	newLen := a.Argument("new", 8)
	oldData := a.Argument("old", 8)
	oldLen := a.Argument("old", 8)

	loop := a.NewLabel("loop")

	a.Start()

	a.Movq(asm.BP, addr)
	a.Xorq(asm.AX, asm.AX)
	a.Xorq(asm.DX, asm.DX)
	a.Movq(asm.BX, newData)
	a.Movq(asm.CX, newLen)

	a.Label(loop)

	a.Lock()
	a.Cmpxchg16b(asm.Address(asm.BP, 0))

	a.Jne(loop)

	a.Movq(oldData, asm.AX)
	a.Movq(oldLen, asm.DX)
	a.Ret()
}

func CompareAndSwapUint128Asm(a *asm.Asm) {
	a.NewFunction("CompareAndSwapUint128")
	a.NoSplit()

	addr := a.Argument("addr", 8)
	oldData := a.Argument("old", 8)
	oldLen := a.Argument("old", 8)
	newData := a.Argument("new", 8)
	newLen := a.Argument("new", 8)
	swapped := a.Argument("swapped", 4)

	a.Start()

	a.Movq(asm.BP, addr)
	a.Movq(asm.AX, oldData)
	a.Movq(asm.DX, oldLen)
	a.Movq(asm.BX, newData)
	a.Movq(asm.CX, newLen)

	a.Lock()
	a.Cmpxchg16b(asm.Address(asm.BP, 0))

	a.Seteq(swapped)
	a.Ret()
}

func LoadUint128Asm(a *asm.Asm) {
	a.NewFunction("LoadUint128")
	a.NoSplit()

	addr := a.Argument("addr", 8)
	data := a.Argument("val", 8)
	length := a.Argument("val", 8)

	a.Start()

	a.Movq(asm.BP, addr)

	for _, r := range []asm.Operand{asm.AX, asm.DX, asm.BX, asm.CX} {
		a.Xorq(r, r)
	}

	a.Lock()
	a.Cmpxchg16b(asm.Address(asm.BP, 0))

	a.Movq(data, asm.AX)
	a.Movq(length, asm.DX)
	a.Ret()
}

func StoreUint128Asm(a *asm.Asm) {
	a.NewFunction("StoreUint128")
	a.NoSplit()

	addr := a.Argument("addr", 8)
	newData := a.Argument("new", 8)
	newLen := a.Argument("new", 8)

	loop := a.NewLabel("loop")

	a.Start()

	a.Movq(asm.BP, addr)
	a.Xorq(asm.AX, asm.AX)
	a.Xorq(asm.DX, asm.DX)
	a.Movq(asm.BX, newData)
	a.Movq(asm.CX, newLen)

	a.Label(loop)

	a.Lock()
	a.Cmpxchg16b(asm.Address(asm.BP, 0))

	a.Jne(loop)
	a.Ret()
}

type functionName string

func (f functionName) String() string {
	return fmt.Sprintf("Â·%s(SB)", string(f))
}

func (functionName) Gas() string {
	panic("referencing functions in unsupported opcodes is forbidden")
}

var _ asm.Operand = functionName("")

func atomic128Asm(a *asm.Asm) {
	SwapUint128Asm(a)
	CompareAndSwapUint128Asm(a)
	LoadUint128Asm(a)
	StoreUint128Asm(a)

	for _, v := range []struct{ name, jmpTo string }{
		{"SwapDoublePointer", "SwapUint128"},
		{"CompareAndSwapDoublePointer", "CompareAndSwapUint128"},
		{"LoadDoublePointer", "LoadUint128"},
		{"StoreDoublePointer", "StoreUint128"},

		{"SwapStringHeader", "SwapUint128"},
		{"CompareAndSwapStringHeader", "CompareAndSwapUint128"},
		{"LoadStringHeader", "LoadUint128"},
		{"StoreStringHeader", "StoreUint128"},

		{"SwapInterface", "SwapUint128"},
		{"CompareAndSwapInterface", "CompareAndSwapUint128"},
		{"LoadInterface", "LoadUint128"},
		{"StoreInterface", "StoreUint128"},
	} {
		a.NewFunction(v.name)
		a.NoSplit()

		a.Start()

		a.Jmp(functionName(v.jmpTo))
	}
}

func main() {
	if err := asm.Do("atomic128_amd64.s", header, atomic128Asm); err != nil {
		panic(err)
	}
}
